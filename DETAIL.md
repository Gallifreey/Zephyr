## 2023雷达站细节文档
### 0. 规格和效率说明
#### 0.1 规格说明
#### 0.2 效率说明
### 1. 路径说明
* `backend`路径：
```
+---core                        # 核心代码
|   +---commands                # 指令，用于外部控制
|   +---crash                   # 异常报告
|   +---hardware                # 硬件
|   |   +---Camera              # 摄像头
|   |   +---Driver              # 驱动
|   |   +---Lidar               # 雷达
|   |   +---Serial              # 串口
|   +---inference               # 推理代码
|   |   +---behavior            # 行为树
|   |   |   +---utils
|   |   +---echo                # 广播
|   |   +---geometry            # 定位
|   |   +---yolov5              # YOLO识别
|   +---library                 # 库文件
|   +---plugins                 # 插件
|   +---utils                   # 杂项代码
+---radar_websocket             # websocket代码
+---resource                    # 资源文件
|   +---assets                  
|   |   \---data                # 配置文件
|   +---behavior_tree_config    # 行为树配置文件
|   +---output                  # 日志输出位置
|   +---pcd                     # PCD点云保存位置
|   +---weights                 # 推理模型保存位置
\---rubbish                     # 弃用和测试代码
```
### 2. 架构设计
![架构图](./assets/pic.bmp)
&emsp;&emsp;本系统利用总线模型来对软硬件进行管理。将程序抽象成插件，通过插件管理器（Plugin Manager）统一为所有独立的插件提供消息订阅、接收、取值、存值等接口。
此外，还配置了日志记录、参数管理、异常拦截、断路保护等特色功能。
### 3. Q&A
* Q: 为什么不使用ROS？
* A: 暂时没有那个必要。目前为止，这个项目不需要外部的对雷达点云处理算法，也不需要其他依赖ROS的包和库。
* Q: 如果不用ROS的话，雷达点云如何获得呢？
* A: 雷达外设本质上是通过网路进行点云数据传输的，如果看官方的驱动就会发现，无疑就是对网络数据包进行解包和发送。这点用什么语言都可以实现，所以，我自己实现了一个Python版的雷达驱动。
* Q: 为什么将展示（UI）和处理分离呢？
* A: 目前为止，前后端分离和分布式管理仍是软件工程领域内开发软件系统首选的架构。前后端将数据处理和数据展示分离，降低了系统的额外开销，降低模块间的耦合度。
* Q: 不用ROS的话，数据同步怎么实现呢？
* A: 目前为止，我给每个数据包添加一个时间戳(timestamp)，把每轮数据包时间戳按距离聚集，以此得到同步的数据组。
* Q: 为什么用Python写，而不是C++？
* A: 可以用C++写，但没有这个必要，Python来的比C++更自由，况且只要保证系统处理频率大于10Hz（30Hz）左右就行。
* Q: 为什么把程序包的那么严？这不会影响程序的运行效率吗？
* A: 为了降低模块间的耦合度，为了两个模块间不能有直接的数据交流只能通过包装一层通讯机制来实现。它确实会影响程序的运行效率，但这点和系统的可复用性、可拓展性来说不值一提。
* Q: 系统的优化怎么样？
* A: 目前为止，使用Windows系统，在把IDE都开着的情况下，平均频率30Hz，大头在推理部分（单纯使用YoloV5双层网络，没有对模型量化）。
* Q: 系统的识别效果如何？
* A: 识别效果受光线环境和摄像头设备采集分辨率有关，识别模型为开源。由于训练成本高，我并未再次训练。根据测试，平均检出率为80%以上，平均识别率为90%以上，能满足一定需求。
### 4. 类说明
#### 4.1 总线
##### 4.1.1 总线基类
&emsp;&emsp;代码请见`library\EventBusBase.py`。 本系统的总线结构简单，就是为模块间的数据传输提供一个公共接口。如果用以前的设计理念，每个模块间需要数据传输时就会用到全局变量，这种的全局变量不好管理，同时也会出现Import的循环引入错误。总线很好的解决了这个问题。<br>
&emsp;&emsp;具体地讲，每个模块（插件）都有一个向总线获取值、删除值和更新值的接口，模块所关注的就是单纯地通过调用这些接口。插件对值进行处理之前，需要对值进行注册（Register），这种注册目前仅支持离线注册（通过注入代码）而不支持在线注册，如果你想为自己的模块注册值，请参考本文档中的“插件”部分。<br>
&emsp;&emsp;除了模块可以向总线对值进行处理操作外，还可以互调模块间的函数，通过加入注解可以在总线注册函数，在使用这些函数时，需要指定函数的键值（名称）、函数的参数来调用。<br>
&emsp;&emsp;为了总线类的唯一性，在此使用单例模式，无论调用/new多少次总线，都仅仅会产生一个实例。此外，为了保护总线的导入安全，请不要在总线基类文件中调用其他的模块（如：摄像头、雷达等模块），这会引起循环导入。<br>
&emsp;&emsp;总线与其他非插件模块间有逻辑联系，比如插件管理器、日志记录、参数管理器等，他们之间的联系请见对应条目。<br>
&emsp;&emsp;目前的总线尚处于一个初级的阶段，等待后续的完善。
<font color="green">代码示例</font>
##### 4.1.2 总线数据（包）类型
&emsp;&emsp;在之前已经说过了，总线的数据被包装成一个数据包，这个数据包的格式如下：

```json
{
  "key": "键值",
  "value": "数据",
  "type": "格式",
  "params": [
    "参数1",
    "参数2"
  ],
  "out": [
    "返回值1",
    "返回值2"
  ],
  "timestamp": 123456789
}
```
这里的`key`是唯一的，总线会在初始化阶段检查是否存在唯一的键值，存在则退出程序。<br>
`value`即为数据，这里的数据是任意格式的，可以为基本数据类型、参数甚至是类。<br>
`type`标识`value`的数据类型，类型定义请见`library\EventBusBase.py`中的`EventBusItemType`枚举类：
```python
import enum

class EventBusItemType(enum.Enum):
    DATA = 1
    FUNCTION = 2
    CLASS = 3
```
`params`为函数参数，列表，可为空。<br>
`out`为函数返回值，列表，可为空。<br>
`timestamp`为时间戳，用于同步，值为`int`，不可为负。
#### 4.2 插件
##### 4.2.1 插件基类
&emsp;&emsp;代码请见`library\PluginBase.py`。它实现了基本的插件封装。<br>
`start`函数标识启动插件，则把插件的资源加载在内存中并启动。<br>
`uninstall`函数标识卸载插件的回调函数，如：卸载摄像头插件则需断开摄像头的连接并释放资源。<br>
`update`函数用于更新处于总线的值，可选函数参数为`key`：键值和`value`：值。如：雷达的点云数据和摄像头的图像数据。<br>
`get`函数用于获得处于总线的值，可选函数参数为`key`：键值。
除了定义以上函数外，还定义了变量：<br>
`plugin_name`标识了插件的名称，唯一，用于日志记录和通过插件名称处理插件。<br>
&emsp;&emsp;通过继承插件基类可创建自定义的插件，若想把本插件的某些值暴露于总线中，请在类全局定义共有变量，并通过注册将该值注册进总线。<br>
&emsp;&emsp;若想暴露自己的创建的函数，请在函数之前加入注解`@subscribe`来标识将本函数注册进总线。<br>
&emsp;&emsp;在本节中，我介绍了几个基本的插件：雷达、摄像头、推理和串口。<br>
<font color="green">代码示例</font>
##### 4.2.2 摄像头插件
&emsp;&emsp;目前为止，暂时不支持双目相机提取双目视野及多相机组的视野同步功能。
* 免驱摄像头（他不能设置相机参数，如：白平衡、曝光时间）

&emsp;&emsp;代码见`core\hardware\Camera\USBCamera.py`,任何摄像头都可以继承`Camera`类，这个相机基类包括了对相机处理的基本接口，只须实现这些接口就可对相机轻松操作:

| 函数名         | 参数  | 返回值 | 说明       |
|-------------|-----|-----|----------|
| `open`      |     |     | 开启摄像头线程  |
| `read`      |     |     | 读取摄像头画面  |
| `close`     |     |     | 关闭摄像头    |
| *`pause`    |     |     | 暂停/开启摄像头 |
&emsp;&emsp;除了提供的函数外，相机还需提供相机基本信息，如：相机标识和相机参数。通过`CameraPlugin`提供的外部接口，相机可以轻松地获得外部数据和向外暴露相机信息。<br>
&emsp;&emsp;要注意的是，相机的`open`函数最好是相机初始化和开启相机进程，这样利于设备管理和资源监控。
* ZED（双目）

&emsp;&emsp;代码见`core\hardware\Camera\ZED.py`。<font color="red">注意：ZED需要配置驱动程序，Python版本需要官方的pyzed库才能运行，配置过程详见配置文档。</font>基本用法如`USBCamera`基本一致，唯一需要的是需要对ZED参数进行管理。这一点在之后会涉及。
##### 4.2.3 雷达插件
&emsp;&emsp;代码见`core\hardware\Lidar\LivoxMid70.py`。这里的雷达是通过雷达SDK进行驱动的（`Driver\LivoxLidarDriver.py`），创建的雷达类也是这个驱动类。目前，这个驱动可以自动检测并连接Livox雷达设备，具体如何配置雷达请见配置文档。它提供了点云录制、深度图捕获、点云回放功能。
##### 4.2.4 推理插件
&emsp;&emsp;目前推理使用YoloV5双层网络模型，第一层检测Car，第二层在第一层基础上检测Armor。两层的检测尺寸不一样，可以动态设置。第二层把第一层检测的所有目标贴到一张图片上（一批次），每张图片尺寸固定，图片间有白色填充，底色也是白色。Armor的筛选逻辑：
* STEP1: 若同一Car中有多个相同的Armor，则按这个Armor标识
* STEP2: 若同一Car中有不同的Armor，选择种类最多的Armor，若种数平均则选择置信度大的一侧

&emsp;&emsp;除了检测逻辑外，还有跟踪逻辑，目前的跟踪局限于短暂的遮挡预测，下面是跟踪逻辑：
* STEP1: 若在检测中存在车辆丢失则认为是跟丢，系统会输最后一次检测到的那个位置
* STEP2: 若检测过程中出现了相同标签但位移较大，系统则会输出最后一次有效检测的那个位置

&emsp;&emsp;检测器输出除了标签、置信度外，还会输出装甲板的ROI图像矩阵。
##### 4.2.5 串口插件
&emsp;&emsp;代码见`core\hardware\Serial\serial.py`。
#### 4.3 插件管理器
&emsp;&emsp;总线不能直接操作插件，而是通过插件管理器（PLM）来间接管理。插件管理器通过安装、运行、卸载操作实现对插件的生命周期的管理。同时，它还会提供插件的热重载功能（实验性功能）以及实现插件运行资源的监控。
#### 4.4 参数管理器
&emsp;&emsp;参数管理器（PAM）通过加载配置文件到总线实现对参数的自动化控制，它不需注册参数，仅仅把配置文件所有的键值和数据加载进内存中，以实现参数的共用。目前，它提供在线修改参数功能。
#### 4.5 指令管理器
&emsp;&emsp;指令管理器（CMM）可通过外部设备访问或执行系统的特定功能。一般用于远程调试和多机通信，它通过一系列指令协议，以最小的资源花费来实现系统的远程遥控。
#### 4.6 异常拦截器
&emsp;&emsp;异常拦截器（EXB）通过拦截一切可能的无用异常来保证程序运行正常，比如：websocket连接异常可以无视。它一般与插件管理器的重启功能有关，即一旦插件运行中出现异常而无法继续运行时，插件管理器会重启那个插件，以维护程序正常运行。
#### 4.7 日志
&emsp;&emsp;日志（LOG）可以通过`Logger`访问日志功能。一般日志可以输出多类紧急程度的提示，同时日志将会记录这些并保存于离线日志保存目录下，以供调试。
#### 4.8 断路保护
&emsp;&emsp;断路保护（BP）是总线或程序的其他重要功能受阻而无法正常运行时，断路保护会重启那部分。
#### 4.9 网络通信
&emsp;&emsp;网络通信，这里一般指前后端使用的websocket通讯机制，与调试界面展示有关。
#### 4.10 模拟器
&emsp;&emsp;模拟器，一般和场景仿真有关，在模拟器提供的环境下，可以通过自定义场景地图，自定义识别物体，来调试算法参数的仿真器。
#### 4.11 广播
&emsp;&emsp;广播指将敌对目标信息广播至所有友方的功能。目前为止，仅有把所有目标的位置广播到串口。
##### 4.11.1 定位
#### 4.12 实验性功能
##### 4.12.1 行为树
&emsp;&emsp;为了更好的决策，在此使用了行为树辅助系统的决策，但目前无此必要。
##### 4.12.2 多智能体决策
&emsp;&emsp;为了弥补行为树单体决策的局限性，在此使用多智能体决策方法，理论上将不同的行为树用在不同的Agent上，形成一套完善的决策体系。
##### 4.12.3 强化学习
&emsp;&emsp;最终版，与强化学习有关，决策不再是通过写好的流程而是通过模型，自动让AI输出应该有的行为。
#### 4.13 其他
##### 4.13.1 EasyImport（资源文件注册模块）
&emsp;&emsp;用于解决资源文件路径过长问题，现在只需使用`ROOT`函数，并写出它的文件名或者加上一级的目录名即可补全所有的路径。
##### 4.13.2 标定助手
&emsp;&emsp;用于辅助摄像头标定，雷达——摄像头标定、摄像头——环境标定。
##### 4.13.3 调试助手
&emsp;&emsp;暂无其他作用。
### 5. 配置文件说明
### 6. 同类产品比较
### 7. 总结与展望
### 8. 参考
